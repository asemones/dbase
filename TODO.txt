implement the io-uring write engine
implement scheduling with coroutines
//complete both by march 31st, fully tested
//do these first
//finish at least basic txn stuff before integration

txn stuff:

proper read/write for txns, consistent etc
properly check l_0 and l_1->l_7 for the correct keys + filter based on the isolation level 
skiplist nodes need to use times or some sort of counting method (could use tx id + clever )
skiplist nodes can store an array of the same keys with different verisons as a solution
to mvcc

add a way for txns to pin pages + memtables and "release" all resources on compeletion. Ideal
for short running OR txns with a high degree of locality, with long ones making their own copies as to not clog up the buffer 
manager

properly pin pages, memtables etc
SOLVED: let the user deal with it. multithreaded access is banned, so in theory values are returned and the
user may decide what is best for their usecase, whether it be to pin memtables or copy values.


properly scan memtables


consider key-value seperation
mirgrate db to use fancier comparisions
cache line bloom filters
merge codebase with new scheduler features

requirements:
1. change cache to the new model
    since everything now needs to be alligned to 4kb pages even with compression, this presents 
    a challenge. find a fix
2. route all requests thru the io io_manager
3. change compactor to function with new system 
4. remove all old synchronization


the way the db may be interacted with: compactor operations, read/write. api calls
become tasks in the scheduler, and the compactor scheduler will just get ran with compactions then becoming
subtasks.